using System;
using System.Net;
using Microsoft.Silverlight.Testing;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using ExpressionSerialization;
using System.Linq.Expressions;
using System.Xml.Linq;
using System.Diagnostics;
using System.Collections.Generic;
using Northwind;
using System.Linq;
using System.Reflection;
using System.Dynamic;
using ObjectServices;


namespace SilverlightTest1
{
	[TestClass]
	public class Tests2
	{
		[TestMethod]
		public void XELementTest()
		{
			XElement xmlTree1 = new XElement("Root",
				new XElement("Child1", 1),
				new XElement("Child2", 2),
				new XElement("Child3", 3),
				new XElement("Child4", 4),
				new XElement("Child5", 5),
				new XElement("Child6", 6)
			);
			foreach (var el in xmlTree1.Elements())
			{
				int value = (int)el;//can cast XElement.Value like this
			}

			XElement xmlTree2 = new XElement("Root",
				from el in xmlTree1.Elements()
				where ((int)el >= 3 && (int)el <= 5)
				select el
			);

			XElement xmlTree3 = new XElement("params", new object[] { new XElement("name", 4.02), new { id = 10013, firstName = "tom" }, 5.7, "string" });
		}


		// Very simple serialization example
		[TestMethod]
		public void BasicExpressionSerialization()
		{
			Debug.WriteLine("BASIC SAMPLE - Serialize/Deserialize Simple Expression:");

			Expression<Func<int, int, int>> addExpr = (x, y) => x + y;
			ExpressionSerializer serializer = new ExpressionSerializer();
			XElement addXml = serializer.Serialize(addExpr);
			Expression<Func<int, int, int>> addExpResult = serializer.Deserialize<Func<int, int, int>>(addXml);
			Func<int, int, int> addExpResultFunc = addExpResult.Compile();
			int result = addExpResultFunc(1, 2);  // evaluates to 3

			Debug.WriteLine("Deserialized Expression Tree:");
			Debug.WriteLine(" " + addExpResult.ToString());
		}

		// Serializing an expression tree representing a query expression
		[TestMethod]
		public void ComplexExpressionSerializationSamples()
		{
			Debug.WriteLine("COMPLEX SAMPLE - Serialize/Deserialize In-Memory Query Expression:");

			Expression<Func<IEnumerable<int>>> queryExp = () => from i in Enumerable.Range(1, 10)
																where i % 2 == 0
																select i * i;

			ExpressionSerializer serializer = new ExpressionSerializer();
			XElement queryXml = serializer.Serialize(queryExp);
			Expression<Func<IEnumerable<int>>> queryExpResult = serializer.Deserialize<Func<IEnumerable<int>>>(queryXml);

			// Print out the expression tree: "(x, y) => x + y"
			Debug.WriteLine("Deserialized Expression Tree:");
			Debug.WriteLine(" " + queryExpResult.ToString());

			// Call it
			Func<IEnumerable<int>> f = queryExpResult.Compile();
			IEnumerable<int> result = f();
			Debug.WriteLine("\nResults: ");
			result.ToList().ForEach(n => Debug.WriteLine(" " + n));
		}


		[TestMethod]

		// Example of querying using LINQ against a LINQ to SQL implementation hidden behind a WCF service
		// Note that no database is being directly referenced - all types and calls are proxies generated by 
		// the service reference.
		public void AcrossTheWireSerializationSamples()
		{
			Console.WriteLine("DLINQ ACROSS THE WIRE SAMPLE - Query against an IQueryable wrapper over a web service:");

			// Query is against a RemoteTable which is a proxy for the the WCF service which executes the DLinq query
			// on the server.  Note that the elements are the service-reference generated types that align with the 
			// DLinq mapping types via the DataContracts.
			QueryProvider provider = null;
			var queryable = new Query<Customer>(provider); //RemoteTable<RemoteQueryService.ServiceReference.Customer>();
			var query = from c in queryable
						where c.City == "London"
						orderby c.ID
						select (from o in c.Orders
								orderby o.OrderDate
								select o.OrderDate).First();

			Console.WriteLine("\n Query Results: ");
			foreach (var c in query)
				Console.WriteLine(" " + c.Value.ToShortDateString());
		}
	}
}
